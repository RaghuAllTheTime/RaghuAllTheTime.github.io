<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blog | Nial Notes</title>

  <link rel="alternate" type="application/atom+xml" title="Razetime" href="/feed.xml">
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Fenix&display=swap"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css"
  />
  <link rel="stylesheet" href="/style.css" />
  
    <link rel="stylesheet" href="/theme.css" />
  
</head>
<body>
  
  <div class="container"><br>
    <a href="/" style="padding-right: 0.5em;">← Home</a>
    <a href="/blog">← Back to Blog</a>
    <br><h2>Nial Notes</h2><p>This is a page of personal notes on Nial that’s published here to help other people lessen their confusion when they are 
writing Nial code.</p>

<h5 id="tips">Tips</h5>
<ul>
  <li>Always have <code class="language-plaintext highlighter-rouge">set "decor</code> on. <code class="language-plaintext highlighter-rouge">set "diagram</code> is useful in certain cases, but is it better to use the <code class="language-plaintext highlighter-rouge">diagram</code> function when you need it.</li>
  <li>for the <code class="language-plaintext highlighter-rouge">-</code> symbol, whitespace matters. <code class="language-plaintext highlighter-rouge">0-9</code>, <code class="language-plaintext highlighter-rouge">0 -9</code> are arrays and <code class="language-plaintext highlighter-rouge">0 - 9</code> is a number.</li>
  <li>Transformers are operators which take a function on the right with if they are single arg.</li>
  <li><code class="language-plaintext highlighter-rouge">see</code> is useful for checking previously defined operations in the repl.</li>
  <li>functions and dynamic vars use <code class="language-plaintext highlighter-rouge">is</code>, ordinary vars use <code class="language-plaintext highlighter-rouge">gets</code>.</li>
  <li>keyword type words are usually capitalized, but you can also just capitalize the first letter because it is simpler.</li>
  <li><code class="language-plaintext highlighter-rouge">[x first]</code> to add a constant <code class="language-plaintext highlighter-rouge">x</code> to an atlas.</li>
  <li><code class="language-plaintext highlighter-rouge">setformat</code> is super useful for printf style things, uses the same format specifiers.</li>
  <li>most arithmetic and boolean ops autoreduce.</li>
  <li><code class="language-plaintext highlighter-rouge">append</code>, <code class="language-plaintext highlighter-rouge">hitch</code>, <code class="language-plaintext highlighter-rouge">pair</code>, and <code class="language-plaintext highlighter-rouge">link</code> are all different concatenation ops and there is usually exactly one correct thing of these you should use.</li>
  <li><code class="language-plaintext highlighter-rouge">sublist</code> extends its right arg, allowing you to specify a periodic pattern.</li>
  <li><code class="language-plaintext highlighter-rouge">pack</code> works like <code class="language-plaintext highlighter-rouge">,⍥⊂¨</code> but with any number of equal length(<code class="language-plaintext highlighter-rouge">?conform</code> will complain otherwise) arrays.</li>
  <li><code class="language-plaintext highlighter-rouge">Pi</code> is a predefined constant. you may want higher precision, however.</li>
  <li><code class="language-plaintext highlighter-rouge">=</code> does not vectorize and <code class="language-plaintext highlighter-rouge">match</code> does (counter intuitive).</li>
  <li>grid is <code class="language-plaintext highlighter-rouge">⍳≢</code></li>
  <li>Nial has a “quote” syntax (<code class="language-plaintext highlighter-rouge">!</code>) that lets you convert functions to values. See <code class="language-plaintext highlighter-rouge">cast</code> and <code class="language-plaintext highlighter-rouge">apply</code> in the dictionary.
    <ul>
      <li>Not exactly first class functions, since they expose an internal numeric-array representation.</li>
    </ul>
  </li>
</ul>

<h5 id="style-guide">Style Guide</h5>
<ul>
  <li>Comments
    <ul>
      <li><code class="language-plaintext highlighter-rouge">%...;</code> comments are recommended for inline comments because they do not require an extra newline.</li>
      <li><code class="language-plaintext highlighter-rouge">#</code> comments are good for shebangs and longer documentation comments.</li>
      <li>Both of them act very weird. The nial parser is strange.</li>
    </ul>
  </li>
  <li>Nial ignores capitalization on all identifiers and primitive names. You can camelcase keywords like <code class="language-plaintext highlighter-rouge">For</code> and 
<code class="language-plaintext highlighter-rouge">While</code> since they don’t behave like ordinary nial constructs.</li>
</ul>

<p><strong>Few equivalences between APL and Nial:</strong></p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Monad</th>
      <th>Dyad</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">⍳</code></td>
      <td><code class="language-plaintext highlighter-rouge">count</code>, <code class="language-plaintext highlighter-rouge">tell</code>(<code class="language-plaintext highlighter-rouge">⎕IO←0</code>)</td>
      <td><code class="language-plaintext highlighter-rouge">find</code>, <code class="language-plaintext highlighter-rouge">findall</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">⍪</code></td>
      <td><code class="language-plaintext highlighter-rouge">post</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">⍴</code></td>
      <td><code class="language-plaintext highlighter-rouge">reshape</code></td>
      <td><code class="language-plaintext highlighter-rouge">shape</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">+/</code></td>
      <td><code class="language-plaintext highlighter-rouge">sum</code>, <code class="language-plaintext highlighter-rouge">+</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">⌈</code></td>
      <td><code class="language-plaintext highlighter-rouge">ceiling</code></td>
      <td><code class="language-plaintext highlighter-rouge">max</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">⌽</code></td>
      <td><code class="language-plaintext highlighter-rouge">reverse</code></td>
      <td><code class="language-plaintext highlighter-rouge">rotate</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">*∘.5</code></td>
      <td><code class="language-plaintext highlighter-rouge">sqrt</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">⍕</code></td>
      <td><code class="language-plaintext highlighter-rouge">string</code></td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">∘.(,⍥⊂)</code></td>
      <td><code class="language-plaintext highlighter-rouge">cart</code></td>
      <td>-</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">/</code></td>
      <td>-</td>
      <td><code class="language-plaintext highlighter-rouge">sublist</code> (bool only)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">∪</code></td>
      <td><code class="language-plaintext highlighter-rouge">cull</code></td>
      <td><code class="language-plaintext highlighter-rouge">cull link</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">⊂</code>,<code class="language-plaintext highlighter-rouge">⊆</code></td>
      <td><code class="language-plaintext highlighter-rouge">single</code>, <code class="language-plaintext highlighter-rouge">solitary</code></td>
      <td><code class="language-plaintext highlighter-rouge">cutall</code>, <code class="language-plaintext highlighter-rouge">cut</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Some notes on functions from iconoclast</strong></p>

<p>If you look at Nial operators as taking 1 argument with no
preconceptions of monadic or dyadic and x, y etc are single expressions
or strands of expressions then</p>

<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">x</span> <span class="nv">fn</span> <span class="nv">y</span> <span class="o">-</span><span class="k">is</span><span class="o">-</span> <span class="nv">f</span> <span class="p">[</span><span class="nv">x</span><span class="p">;</span><span class="nv">y</span><span class="p">]</span>                  <span class="nv">by</span> <span class="nv">convention</span>
  <span class="nv">fn</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="o">...</span> <span class="o">-</span><span class="k">is</span><span class="o">-</span> <span class="nv">fn</span> <span class="p">[</span><span class="nv">x</span><span class="p">,</span><span class="nv">y</span><span class="p">,</span><span class="nv">z</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>     <span class="nv">strand</span> <span class="k">is</span> <span class="kp">single</span> <span class="nv">arg</span>
  <span class="p">[</span><span class="nv">fn1</span><span class="p">,</span><span class="nv">fn2</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="nv">x</span>  <span class="o">-</span><span class="k">is</span><span class="o">-</span> <span class="p">[</span><span class="nv">fn1</span> <span class="nv">x</span><span class="p">,</span> <span class="nv">fn2</span> <span class="nv">x</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>   <span class="nv">atlas</span>
</code></pre></div></div>
<p>atlases are functions so can be composed and nested with
other functions (including atlases) e.g. average is</p>
<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">/</span><span class="p">[</span><span class="o">+</span><span class="p">,</span><span class="kp">tally</span><span class="p">]</span>
</code></pre></div></div>
<p>This is just function composition in a tacit form.</p>

<p>Nial doesn’t have conventions on verb trains such as the ‘hook’, its
functional and doesn’t need them. Just write f[g,h], a composition
of two functions for the hook.</p>

<p>If you want to formalise this Nial has a form of HOF called a transformer so
in a tacit style you can write</p>
<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">hook</span> <span class="k">is</span> <span class="k">tr</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="p">(</span><span class="nv">f</span><span class="p">[</span><span class="nv">g</span><span class="p">,</span><span class="nv">h</span><span class="p">])</span>
</code></pre></div></div>
<p>then you can write</p>
<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="nv">average</span> <span class="k">is</span> <span class="nv">hook</span><span class="p">[</span><span class="o">/</span><span class="p">,</span><span class="o">+</span><span class="p">,</span><span class="kp">tally</span><span class="p">]</span>
</code></pre></div></div>
<p>If you prefer a non-tacit style then you can write</p>
<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nv">hook</span> <span class="k">is</span> <span class="k">tr</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="k">op</span> <span class="nv">x</span> <span class="p">{</span> <span class="p">(</span><span class="nv">g</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">f</span> <span class="p">(</span><span class="nv">h</span> <span class="nv">x</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>
<p>OP is Nial’s lambda.</p>

<p>Nial has multiple assignment</p>
<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="p">:=</span> <span class="kp">tell</span> <span class="mi">3</span>
</code></pre></div></div>
<p>So in a sense you can write an operator with multiple arguments as</p>
<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">op</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="p">{</span> <span class="o">....</span> <span class="p">}</span>
</code></pre></div></div>
<p>or as</p>
<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">op</span> <span class="nv">args</span> <span class="p">{</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="p">:=</span> <span class="nv">args</span><span class="p">;</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div></div>
<p>The interpreter will handle the first form more efficiently.</p>

<hr />

<p>IS is not the same as := (gets). One is a definition, the other
an assignment. For example</p>

<div class="language-nial highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">x</span> <span class="p">:=</span> <span class="mi">10</span>

  <span class="nv">a</span> <span class="p">:=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nv">x</span>

  <span class="nv">b</span> <span class="k">is</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nv">x</span><span class="p">)</span>
</code></pre></div></div>

<p>a is now 21 and will stay that way until reassigned however b
is 1+x whatever x is and if x changes then evaluating b will too.</p>
</div>
</body>
</html>
